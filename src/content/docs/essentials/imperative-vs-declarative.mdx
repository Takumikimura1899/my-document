---
title: 命令型と宣言型プログラミングの使い分け
description: 両パラダイムの特徴とトレードオフを整理し、プロジェクトで適切に選択・併用するための指針をまとめます。
---

## このドキュメントの目的

- 新しい機能やリファクタリングの議論で「どちらのパラダイムを採用するか」を揃えやすくする
- コードレビュー時に議論が迷走しないよう、観点と評価軸を言葉にしておく
- チーム内で暗黙知になりがちなベストプラクティスを明文化する

## 基本的な考え方

### 命令型プログラミング

- 「どの手順で結果を得るか」を逐次的に記述するスタイル
- 状態の変化を強く意識し、制御構造（変数、ループ、分岐）を直接扱う
- ローレベルな制御がしやすく、パフォーマンスや細かな例外処理を最適化しやすい

### 宣言型プログラミング

- 「何を実現したいか」を表明し、実現方法は抽象化された仕組みに委ねるスタイル
- 副作用を抑え、データフローや制約を中心に記述することが多い
- 読み手が意図を把握しやすく、並列化や最適化をフレームワーク側に任せやすい

### 関数型プログラミング

- 関数型は宣言型パラダイムの一種
- 不変データと純粋関数を基本とし、副作用を最小限に抑える設計手法
- 宣言型の利点を活かしつつ、並行性やテスト容易性を高める

## 観点別の比較

| 観点         | 命令型                                                        | 宣言型                                                        |
| ------------ | ------------------------------------------------------------- | ------------------------------------------------------------- |
| 記述の焦点   | 手順と状態の更新                                              | 意図と制約の表明                                              |
| 状態管理     | 可変データと副作用が前提                                      | 不変データや副作用の隔離を重視                                |
| 可読性       | 詳細な動作が明確になる一方で、手続きが長くなりやすい          | 意図を短く表現できるが、抽象化の理解が必要                    |
| テスト容易性 | 個々のステップを検証しやすいが、モックが多くなりがち          | 入出力に集中でき、プロパティベーステストと相性が良い          |
| 拡張性       | 新しい分岐やステップを追加しやすい                            | 抽象の境界が固まると柔軟性を損ねることがある                  |
| 代表的な領域 | システムプログラミング、UI の細かな制御、パフォーマンス最適化 | SQL、React の JSX、状態管理ライブラリ、Infrastructure as Code |

## 例で見る違い

以下は「偶数のユーザー ID を大文字化して連結する」という処理を JavaScript/TypeScript で表現した例です。

<details>
  <summary>👨‍💻 命令型の実装</summary>

```typescript
const ids = [101, 102, 103, 104]
let result = ''

for (let index = 0; index < ids.length; index += 1) {
  const id = ids[index]
  if (id % 2 === 0) {
    result += `USER-${id.toString().toUpperCase()}`
  }
}

console.log(result) // "USER-102USER-104"
```

- 実行手順を一行ずつ追いやすく、ログを挟んだデバッグが簡単
- 状態 `result` の初期化と更新タイミングを自前で管理する必要がある

</details>

<details>
  <summary>🧠 宣言型の実装</summary>

```typescript
const ids = [101, 102, 103, 104]

const result = ids
  .filter((id) => id % 2 === 0)
  .map((id) => `USER-${id.toString().toUpperCase()}`)
  .join('')

console.log(result) // "USER-102USER-104"
```

- フィルタ・変換・結合という意図が関数の連鎖で表現される
- 途中結果へのアクセスやループの抜け方などは抽象化に委ねる

</details>

## 選定の観点

- **制御の粒度**: ハードウェアリソース管理やレンダリングの最適化が必要なら命令型が適していることが多い
- **ドメインの複雑性**: ビジネスルールを言語化したい場合は宣言型で意図を先に表現する方が保守しやすい
- **チームの習熟度**: 抽象化された DSL や宣言的 API に不慣れなメンバーが多い場合は、段階的に導入する
- **テスト戦略**: 状態遷移を逐次検証したいなら命令型、入出力の性質を網羅したいなら宣言型がマッチしやすい
- **並行性の要求**: 共有状態の同期コストがボトルネックになる場合は、不変データと副作用の分離を重視した関数型パターンが有効
  （[Functional programming - Wikipedia](https://en.wikipedia.org/wiki/Functional_programming#Efficiency_issues)）。
- **フレームワークとの整合**: React や Terraform のように宣言的なモデルを前提としたツールでは、命令型を持ち込むと整合性が崩れる

## チームでの合意事項

- パフォーマンスや副作用を理由に命令型へ寄せる場合は、PR で「なぜ宣言型が適さないか」を明記する
- 宣言型の抽象を導入する際は、サンプルコードと撤退基準（必要ならロールバックできる条件）をセットで共有する
- 同じ機能内でスタイルが混在しないよう、境界（例: API レイヤーは宣言型、インフラレイヤーは命令型）を先に定義する
- ドキュメントが古くなった場合に備え、実際のユースケースから逆引きできるリンクを追記していく
- ドメインロジックは副作用のない純粋関数から着手し、必要な副作用は境界に集約する方針を共有する
  （[React 公式ドキュメント](https://react.dev/learn/keeping-components-pure) を参照）。

## レビュー時のチェックリスト

- 可読性と意図の明確さはどちらのパラダイムで最大化できているか？
- 状態のライフサイクルと副作用を追跡しやすい構造になっているか？
- フレームワークやライブラリの推奨スタイルに従っているか？
- 将来の拡張やロジック追加に備えた抽象の厚さが妥当か？
- 例外やエラー処理が、選んだパラダイムと矛盾せずに組み込まれているか？
