---
title: フロントエンドの状態管理
description: 現代のフロントエンドアプリケーションにおける状態管理の基本概念について解説します。
---

## このドキュメントの目的

- 現代のフロントエンドアプリケーションは、多くの「状態（State）」を管理する必要があります。状態管理の設計は、アプリケーションの保守性、パフォーマンス、そして開発体験に直接影響を与えます。
- このドキュメントでは、まずフロントエンドが扱う普遍的な3つの状態を定義し、その上でReact Server Components (RSC) のような新しいアーキテクチャが、これらの状態管理をどのように進化させるかについて解説します。

## フロントエンドが扱う普遍的な3つの状態

- どのようなフレームワークやアーキテクチャであっても、フロントエンドが管理すべき状態は、そのスコープと性質から以下の3つに大別できます。

### 1. ローカルステート (Local State)

特定のコンポーネント内でのみ利用される、局所的な状態

- 単一のコンポーネントに閉じており、他のコンポーネントと共有する必要がない状態です。
- 最もシンプルで管理が容易です。
- ユーザのインタラクションに直結しており、UIの即時反映などが求められます。
- 具体例
  - フォームの入力値
  - アコーディオンやドロップダウンの開閉状態
  - 特定のUI要素の表示/非表示フラグ
- 管理方法
  - React: useState, useReducer

```JavaScript
function Counter() {
    const [count, setCount] = useState(0);
    return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

### 2. グローバルステート (Global State)

アプリケーション全体で共有され、複数のコンポーネントからアクセスされる状態

- サーバーとは直接関係なく、クライアント側のUIの振る舞いや複数コンポーネントで共有するデータを管理します。
- 「Propsのバケツリレー」を回避するために用いられることもあります。
- 具体例
  - UIテーマ（ダークモードのON/OFF）
  - ユーザーの認証情報（ログイン状態）
  - 言語設定
  - ショッピングカートの中身
- 管理ライブラリ
  - Zustand, Redux, Jotai, ContextAPI

### 3. サーバーサイドステート (Server-Side State)

サーバーが所有する「真実のデータ(Source of Truth)」であり、クライアントはそれを非同期で取得・更新する状態

- クライアント側では、このサーバーの状態をキャッシュとして保持しているに過ぎません。このキャッシュをいかにサーバーと同期させるかが重要になります。
- 具体例
  - ユーザープロフィール
  - ブログ記事の一覧
  - 商品データ
- 特徴
  - 非同期API (fetch など) を通じて取得・更新する
  - ローディング状態やエラー状態を持つ
  - キャッシュ、再取得、データの無効化といった複雑なロジックを必要とする
- 管理ライブラリ
  - TanStack Query (旧React Query), SWR, RTK Query

## RSCによる状態管理の進化

- React Server Components (RSC) は、上記の3つの状態、特に「サーバーサイドステート」の扱い方を根本から変える新しいアーキテクチャです。
- RSCは状態管理ライブラリではなく、コンポーネントをサーバーでレンダリングするという新しい仕組みです。

### RSCが解決すること

- 従来のクライアントサイドレンダリング（CSR）では、サーバーサイドステートの取得はクライアントの役割でした。

▼ 従来（CSR）のデータ取得フロー

1. クライアントでコンポーネントが描画される
2. useEffectやTanStack QueryでAPIを叩き、ローディング状態を表示
3. データ取得後、状態を更新して再描画

このフローは、クライアント側のコードを複雑にし、表示までに複数回の通信（ウォーターフォール）が発生する原因となっていました。
RSCは、このデータ取得の責任をサーバー側に移します。

▼ RSCのデータ取得フロー

1. サーバーでRSCがデータベース等へ直接アクセスし、データを取得
2. データを使ってサーバーでコンポーネントをレンダリング
3. 完成したHTMLに近いものをクライアントに送信し、即座に表示

これにより、クライアントは初期表示のためのデータ取得ロジックやローディング状態の管理から解放され、コードがシンプルになります。

### RSC登場後の状態管理の役割

RSCアーキテクチャを採用すると、各状態の役割は以下のように変化します。

#### サーバーサイドステート

- 役割の変化が最も大きい領域。
- **RSC:** 初期データの取得を担当。クライアントは完成したUIを受け取るだけ。
- **TanStack Queryなど:** データの更新（Mutation）や、クライアントの操作に応じて発生する動的なデータ取得（無限スクロールなど）の役割が中心になる。役割が限定されることで、より見通しが良くなる。

#### グローバルステート / ローカルステート

- 役割は変わらない。
- これらは元々クライアント側のインタラクティビティを管理するための状態であり、RSCが登場した後もその責務は不変。useStateやZustandなどは引き続き重要な役割を果たします。
- インタラクションに近いものほどローカルステートとして管理し、広範囲に影響するものはグローバルステートとして整理することが推奨されます。カギは影響範囲を最小化し、必要な部分だけに状態を伝播させることです。

## まとめ

フロントエンドの状態管理を設計する際は、まず **「ローカル」** **「グローバル」** **「サーバー」** の3つの普遍的な概念で状態を分類することが基本となります。
その上で、RSCのような新しいアーキテクチャは、特に「サーバーサイドステート」の扱いをサーバー側に寄せることで、クライアントの責務を軽減し、パフォーマンスと開発体験を向上させます。
現代のフロントエンド開発では、これらの状態を適切に分類し、それぞれの役割に最適なツールとアーキテクチャを選択することが求められます。
